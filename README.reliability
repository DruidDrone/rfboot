In the following section lets imagine a electronic project wich is hard
to access physically such as weathering station on the roof. We use the cc1101 chip
to fetch data, but we also want to update the code via the RF link

Here is explined what rfboot does to acomplish this job reliably

A bootloader runs only at power on or after a MCU Reset
One of the main goals of rfboot is to upload the firmware reliably, without physical access to the device including the Reset button.
This means that the application must implement a mechanism to software reset the MCU whenever
we need to update the firmware. A simple solution is to listen for incoming RF packets. When a packet arrives containing exactly the string
ie "Reset" then the application resets the device giving control to rfboot. The rftool utility, whenever creates a new empty project has ready 
such a mechanism in the .ino file. Also the examples contain this solution
As long as this mechanism works, we can upload code to the device literally thousands of times, without any need to even touch the device
. if however the device for some reason stops responding to the reset request, then it is
impossible to reprogram it remotely. We need to access the reset button wich is not very easy sometimes. rfboot is designed
to avoid this type of failure

This is acomplished:
- If the upload process is interrupted, rfboot detects it and waits for new firmware.
- At the event of a power loss or MCU reset while programming, when the power comes back rfboot
will detect the corrupted code and stays waiting for new firmware. When eventually the upload
process finishes correctly, only then rfboot gives control to the app
- Additionally rfboot enables watchdog timer (reset in 2s) before the application starts. If for some reason the
application is malfunctioning, watchdog timer will eventually reset the device allowing to reprogram it
- The danger to upload the wrong code to a device is minimal to not existent. Every atmega chip with rfboot intalled in it, 
can (and should) have a rfboot listening to
different channel syncwords etc. 
Even if we work in parrallel with multiple projects, the code always gows to the correct MCU 

