In the following section lets imagine a electronic project wich is hard
to access physically such as weathering station on the roof. We use the cc1101 chip
to communicate with the station, but we also want to update the code via the same RF link.
And the most important, whatever failure happens while uploading, we should be able to
repeat the process until we succeed.

Here is explained what rfboot does to accomplish this job

A bootloader runs only at power on or after a MCU Reset
This means that the application must implement a mechanism to software reset the MCU, whenever
we need to update the firmware. A simple solution is to listen for incoming RF packets.
When a incoming packet contains exactly the string ie "Reset" then the application resets
the device giving control to rfboot.

The rftool utility, whenever creates a new empty project with "rftool create ProjName"
genarates such a mechanism in the .ino file. Also the examples contain this solution

As long as this mechanism works, we can upload code to the device literally thousands of
times, without any need to even touch the device. if however the device for some reason
stops responding to the reset request, then it is impossible to reprogram it remotely.
We need to access the reset button (we need to go to the roof!).

rfboot is avoids this type of failure :

- If the upload process is interrupted, rfboot detects it and waits for new firmware.
- At the event of a power loss or MCU reset while programming, when the power comes back rfboot
will detect the corrupted code and stays waiting for new firmware. When eventually the upload
process finishes correctly, only then rfboot gives control to the application
- rfboot enables the watchdog timer before the application starts. If for some reason the
application is malfunctioning, watchdog timer will eventually reset the device allowing to reprogram it
- Every time rftool creates a new empty project, gives unique channel, syncword, and XTEA
key to the project. This is in turn makes impossible to send the code to the wrong device. 
Even if we work in parallel with multiple modules, the code always goes to the correct MCU 

