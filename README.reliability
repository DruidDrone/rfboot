In the following section lets imagine a electronic project wich is hard
to access physically such as weathering station on the roof. We use the cc1101 chip
to fetch data, but we also want to update the code via the RF link

Here is explained what rfboot does to accomplish this job reliably

A bootloader runs only at power on or after a MCU Reset
One of the main goals of rfboot is to upload the firmware reliably, without physical access to the device including the Reset button.
This means that the application must implement a mechanism to software reset the MCU, whenever
we need to update the firmware. A simple solution is to listen for incoming RF packets.
When a incoming packet contains exactly the string ie "Reset" then the application resets
the device giving control to rfboot.
The rftool utility, whenever creates a new empty project with "rftool create ProjName"
genarates such a mechanism in the .ino file. Also the examples contain this solution
As long as this mechanism works, we can upload code to the device literally thousands of
times, without any need to even touch the device. if however the device for some reason
stops responding to the reset request, then it is impossible to reprogram it remotely.
We need to access the reset button (we need to go to the roof!). rfboot is designed
to avoid this type of failure

This is accomplished:
- If the upload process is interrupted, rfboot detects it and waits for new firmware.
- At the event of a power loss or MCU reset while programming, when the power comes back rfboot
will detect the corrupted code and stays waiting for new firmware. When eventually the upload
process finishes correctly, only then rfboot gives control to the application
- rfboot enables the watchdog timer before the application starts. If for some reason the
application is malfunctioning, watchdog timer will eventually reset the device allowing to reprogram it
- Every time rftool creates a new enpty project, gives unique channel, syncword, and XTEA
key to the project. This is in turn makes impossible to send the code to the wrong device. 
Even if we work in parallel with multiple modules, the code always goes to the correct MCU 

